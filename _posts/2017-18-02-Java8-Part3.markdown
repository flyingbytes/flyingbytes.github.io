---
layout: post
title:  "An Introduction to Functional Programming in Java 8: Part 3 - Streams"
date:   2017-02-04 13:00:00 +0100
categories: programming java8 functional part3
---

Hello everybody,

In the [last part][part2], we've learned about the Optional type and how to use it correctly. Today, we will learn about `Streams`, which you use as an functional alternative of working with Collections, Iterables and so on.
Some method were already seen when we used Optionals. I won't explain them all in detail again, so be sure to check out [the part about Optionals][part2]

TODO reduce, joining, collector,...
TODO in part 0, 1, 2, jeweils referencen auf diesen part.

## Where do we use Streams?

You might ask what's wrong with the current way to store multiple objects? Why shouldn't you use Lists, Sets and so on anymore?

I want to point out: Nothing is wrong with them. But when you want to work functional (what you hopefully want after the last parts of this blog), you should consider using them.
The standard workflow is to convert to transform your data structure into a Stream. Then you want to work on them in a functional manner and in the end, you transform them back into the data structure of your choice.

And that's the reason we will learn to transform the most common data structures into streams.

## How to Convert Data Structures into Streams

TODO Convert Array
TODO IntStream
### Converting Collections (Lists, Sets, ...)

Luckily, Oracle has thought through the implementation of Streams in Java 8. Every Class that implements [java.util.Collection<T>][javaDocCollection] has a new method called `stream()` which converts the collection into a Stream. It's as easy as it get's.

{% highlight java %}
public void convertStuff() {
    Set<String> set = new HashSet<>();
    List<Integer> list = new LinkedList<>();

    Stream<String> setStream = set.stream();
    Stream<Integer> listStream = list.stream();
}
{% endhighlight %}

### Converting Iterables
TODO Flatmap optionals part 2, auch in DZone ändern
The conversion of an Iterables into a Stream is a bit trickier. However, Oracle also introduced the `StreamSupport` class to help with them.

{% highlight java %}
public void convertStuff() {
    Iterables<String> iter = new Iterable<>();

    Stream<Integer> iterStream = StreamSupport.stream(iterable.spliterator(), false);
}
{% endhighlight %}
...

However, normally you won't store a Stream as an object. You just work with them and convert them back into your desired data structure.

## Working with Streams
As I already said, Streams are the way to work with data structures functional. And now we will learn about the most common methods to use.
In the next TODOAbschnitten, I will use T as the type of the objects in the Stream.

### Methods we already know
TODO Vergleiche mit OOP programming
You can use some methodes we already heard about when we learned about Optionals also with Streams.
#### map and flatMap
These work pretty straight forward. Instead of manipulating one item, which might be in the Optional, we manipulate all items in a stream

{% highlight java %}
public void showMap() {
    List<Integer> numbers = Arrays.of(1, 2, 3)

    numbers.stream()
        .map(num -> num * num)
        .forEach(System.out::println) // -> 1 4 9
}
{% endhighlight %}

TODO Flatmap

{% highlight java %}
public void showFlatMap() {
    List<Integer> numbers = Arrays.of(0, 1, 2, 3)

    numbers.stream()
        .flatMap(num -> divide(1, num))
        .filter(Optional::isPresent)
        .map(Optional::get) // TODO Sag dazu, dass man diese 2 Zeilen in Java 9 durch .flatMap(Optional::stream) ersetzen kann + Verweis talk
        .forEach(System.out::println) // -> 1 4 9
}

public Optional<Integer> divide(Integer first, Integer second) {
    if(second == 0) {
       return Optional.empty();
    }

    return Optional.of(first / second);
}
{% endhighlight %}

And in these examples, we already TODOwitrklichsaw other Stream method, which I will describe now.

### Common Stream methods
TODO ist map mit side effects
TODO PArallelstreams

#### forEach
forEach is like map, but you use it when you have side effects. As already shown, you use it to e.g. print all object in a stream.

{% highlight java %}
public void showFilter() {
    List<Integer> numbers = Arrays.of(0, 1, 2, 3)

    numbers.stream()
        .forEach(System.out::println) // -> 0, 1, 2, 3
}
{% endhighlight %}

#### filter
Filter is a really basic method. It takes a 'test' function that takes a value and returns boolean. So it test every object in the Stream. If it passes the test, it will stay in the Stream or otherwise, it will be taken out. So this 'test' function has the type `Function<T, Boolean>`. In the [JavaDoc][streamJavaDoc], you will see that the test function really is of the type `Predicate<T>`. But this is just a short form for every function that takes one parameter and returns a boolean.


{% highlight java %}
public void showFilter() {
    List<Integer> numbers = Arrays.of(0, 1, 2, 3)

    numbers.stream()
        .filter(num -> num < 2)
        .forEach(System.out::println) // -> 0, 1
}
{% endhighlight %}

TODO Schreiben, dass stream() ursprünglcihen Datensatz **Nicht** verändert.

#### collect
As I already said, you want to transform your stream back into another data structure. And that is what you use Collect for. And most of the times, you convert it into a List or a Set.

{% highlight java %}
public void showCollect() {
    List<Integer> numbers = Arrays.of(0, 1, 2, 3)

    List<Integer> filtered = numbers.stream()
        .filter(num -> num < 2)
        .collect(Collectors.toList())
}
{% endhighlight %}

But you can use collect for much more. For example, you can join Strings. Therefore, you don't have the nasty delimeter in the end of the string.

{% highlight java %}
public void showReduceConcat() {
    List<Stream> words = Arrays.of("Who", "are", "you?")

    Stirng sentence = Stream.of("Who", "are", "you?")
        .collect(Collectors.joining(" "))

    System.out.println(sentence) --> Who are you ?

}
{% endhighlight %}

### Shortcuts

These are methods which you could emulate by using map, filter and collect, but these shortcut method are meant to be used because they declutter your code.

#### reduce
Reduce is a very cool function.
It takes a start parameter of type T and a Function of type `BiFunction<T, T, T>`. If you have a BiFunction, where all types are the same, `BinaryOperator<T>` is a shortcut for that.
It basically stores all objects in the stream to one object. You can concat all Strings into one String, sum all Numbers and so on. There, your star parametrs would be the empty String or zero. This function helps a lot to make your code more readable if you know how to use it.

TODO Mehr dazu schreiben. Von welcher Seite wird reduziert, wozu start parameter
TODO Nicht Strings concaten, mach ich oben mit collect schon besser.

{% highlight java %}
public void showReduceConcat() {
    List<Stream> words = Arrays.of("Who", "are", "you?")

    Stirng sentence = numbers.stream()
        .reduce("", (acc, s) -> acc.concat(" ").concat(s))

    System.out.println(sentence) --> "Who are you ? "

}

public void showReduceSum() {

    Integer sum = Stream.of(0, 1, 2, 3) //TODO Das überall nutzen und einführen
        .reduce(0, Integer::sum)

    System.out.println(sum) --> 6
}
{% endhighlight %}

But as you can see, reduce produces a nasty space in the end of the String in this example. But good for us, there is also a method to help us with this

#### sorted
TODO Example Personen(Filter alle kleine vorname l, sort by nachname, dann vornahme), 11 mapToInt Example
TODO Categorie Streams vor Tests, anymatch
You can also use Streams to sort your data structure. The class type of the objects in the Stream doesn't even have to implement `Comperable<T>`, because you can write your own `Comperator<T>`. This is basically a `BiFunction<T, T, int>`, but Comperator is a shortcut for all BiFunctions that take 2 arguments of the same type and return an int. And this int, like in the `compareTo()` function, shows us, if the first object is "smaller" than the first one (int < 0), is as big as the second (int == 0), or if it's bigger than the second one (int > 0).

The sorted function of the Stream will interpret these ints and will sort the elements with the help of it.

{% highlight java %}
public void showReduceSum() {

    Stream.of(3, 2, 4, 0) //TODO Das überall nutzen und einführen
        .sorted((c1, c2) -> c1 - c2)
        .forEach(System.out::println) // -> 0,2,3,4

}
{% endhighlight %}

#### Other Kinds of Streams
There are also special types of Streams, which only contains numbers. With them, you also have a new TODOset? of functions. Here I will introduce IntStream and Sum, but there are also LongStream, DoubleStream,... . You can read more about them in the [JavaDoc][streamJavaDoc].

To convert a normal Stream into an IntStream, you have to use `mapToInt`. It does exactly the same as the normal map, but you get a IntStream back. Of course, you have to give the mapToInt function another function, which will return an int.

Here, I will show you how to sum numbers without reduce, but with an IntStream

TODO Predicate.negate, Objects::nonNull

{% highlight java %}
public void sumWithIntStream() {
    List<Integer> numbers = Arrays.of(0, 1, 2, 3)

    Integer sum = numbers.stream()
        .mapToInt(id) // Takes the argument and returns it back
        .sum()
}
{% endhighlight %}

### Use Streams for Tests
TODO Sag, dass forEach Stream nicht zurück gibt. Deshalb ist es, wenn es denn gebraucht wird, immer als letzte Methode genutzt. Man sollte damit aber vorsichtig sein, da es nunmal Sde Effects hat und man sollte nochmal überlegen, ob es nicht auch anders geht!
Tests can also be used to test your methods. I will use the method `anyMatch` here, but `count`, `max` and so on. If something goes wrong, use `peek` to log data. It's like forEach, but also returns the stream. As always, look into the [JavaDoc][streamJavaDoc] to find other cool methods.

`anyMatch` is a little bit like filter, but it tells you if anything passes the filter. You can use this in `assertTrue()` tests, where you just want to look if one (or many) particualar objects have a specific property.
In the next example, I will test if a specific name was stored in the DB.


{% highlight java %}

@Test
public void testIfNameIsStored() {
    String testName = "Albert Einstein";

    Datebase names = new Datebase();
    names.drop();

    db.put(testName);
    assertTrue(db.getData()
        .stream()
        .anyMatch(name -> name.equals(testName)));
}
{% endhighlight %}

### Shortcuts of Shortcuts
And after I showed you some shortcut methods, I want to tell you that there are many more. There are even shortcuts of shortcuts! One Example would be `forEachOrdered`, which compines `forEach` and `sorted`. If you are intrested in other helpful methods, watch into the [JavaDoc][streamJavaDoc]. I'm sure you are prepared to understand it and find the methods that you need. Always remember: If it looks ugly, there's a better method to use 😉.

### A Bigger Example
In this example, we want to send a message to every user whose birthday's today.

#### The User Class
A user is defined by their username and it's birthday. The birthdays will be in the format "day.month.year", but we won't do much checking for this in today's example.

{% highlight java %}
public class User {

    private String username;
    private String birthday.

    public User(String username, String birthday) {
        this.username = username;
        this.birthday = birthday;
    }

    public String getUsername() {
        return username;
    }

    public String getBirthday() {
        return birthday;
    }

}
{% endhighlight %}

To store all users, we will use a List here. In a real program, you might want to switch to a DB.

{% highlight java %}
public class MainClass {

    public static void main() {
        List<User> users = new LinkedList<>();

        User birthdayChild = new User("peter", "20.02.1990");
        User otherUser = new User("kid", "23.02.2008");
        User birthdayChild2 = new User("bruce", "20.02.1980");

        users.add(todayBirthday, otherUser);

        greetAllBirthdayChilds(users); // Will be implemented in the next TODOAbschnitt.
    }

    private static void greetAllBirthdayChilds(List<Person> users) {
        // TODO In next TODOparagraph
    }

}
{% endhighlight %}

#### The greet TODOoderGreeting?

Now, we want to greet the birthday childs.
So first off, we have to filter out all Users whose birthday is today. After that, we have to message them. So let's do this.

I won't implement `sendMessage(String message, User receiver)` here, but it just sends a message to a given user.

{% highlight java %}
public static void greetAllBirthdayChilds(List<Person> users) {
    String today = "20.02"; //Just to make the example easier. In production, you would use LocalDateTime or so.
    users.stream()
        .filter(user -> user.getBirthday().startsWith(today))
        .forEach(sendMessage("Concratulations TODOto your birthday, ".concat(user.getName()).concat("!")));
}

private static void sendMessage(String message, User receiver) {
    //...
}
{% endhighlight %}

And now we can send greetings to the users. How nice and easy was that?!

TODO Baue Splitter im nächsten Part
## Conclusion
TODO Falls Methoden für Streams fehlen, lasst es mich gerne wissen
TODO Was in nächsten part? RxJava?
That's it for today!
We have learned a lot about Streams in Java. We learned how to convert a data structure into a Stream, how to work with a Stream and how to convert your Stream back into a data strcuture. I have introduced the most common methods and when you should use them. In the end, we tested our knowledge with a bigger example, where we greeted all birthday childs.

In the next part of this series, we will have a big example where we are going to use Streams. But I won't tell you the example yet, so be surprised.

Are there any Stream methods that I should've also talked about? Please let me know this in the comments

Thanks for reading and have a nice day,

Niklas

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//flyingbytes.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

[part2]: https://flyingbytes.github.io/programming/java8/functional/part2/2017/02/04/Java8-Part2.html
[javaDocCollection]: https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html
[streamJavaDoc]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
