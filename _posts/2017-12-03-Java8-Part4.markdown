---
layout: post
title:  "An Introduction to Functional Programming in Java 8: Part 4 - Splitter"
date:   2017-02-18 13:00:00 +0100
categories: programming java8 functional part4
---
Hello everybody,

In the [last parts][part3], we've learned about the most basic ways to program functional in Java. We used functions as Objects, Streams and so on for this.

Today, we want to create a useful example with them. You will train the paradicmas of the last parts and learn how the optimize the run time of your program.

## Example: Split a Stream by a specific filter

You might have stumbled over a problem like this before: You have a collection of objects and want to split them by a specific filter. After that, you want to perform some action with all elements who passed the test and another action with the ones that didn't passed the test.

### The Basic (and Slow) Approach

{% highlight java %}
public void splitAndPerform(Collection<T> items, Pedicate<T> splitBy, Function<T> passed, Function<T> notPassed) {
    items.stream()
        .filter(splitBy)
        .forEach(passed)

    items.stream()
        .filter(Predicate.negate(splitBy))
        .forEach(notPassed)
}
{% endhighlight %}

This approch works, but it is pretty slow. The run time for splitting alone is O(2n), because we go through the whole collection 2 times: Ones to get all the items that passed the test and ones to get all the items that didn't passed it.

But what if we would create a splitter on our own? It'd sort all items in the collection, depending on whether or not they pass the test, into one List or the other. This would lower the run time to split the collection to O(n), because you just have to call filter once, not twice.

So let's do this.

## The Better Approach
### 1. Split the Collection

The first step to building our splitter is to, you guessed it, split it.

In our `splitBy()` function, we want to take a `Predeciate<T>` as a parameter and return a new `Splitter` object, which is basically an objects which consists of two Lists. One List consists of all the objects that passed the test, and the other one of all the objects that didn't pass the test.

{% highlight java %}
public class Splitter<T> {

    private List<T> passed;
    private List<T> notPassed;

    private Splitter(List<T> passed, List<T> notPassed) {
        this.passed = passed;
        this.notPassed = notPassed;
    }

    public splitBy(Predicate<T> test, Collection<T> items){
        List<T> passed = new LinkedList<T>
        List<T> notPassed = new LinkedList<T>

        items.stream()
                .forEach(item -> {
                    if(test.apply(item)){
                        passed.add(item)
                        return;
                    }
                    notPassed.add(item)
                });

        return new Splitter(passed, notPassed);
    }

}
{% endhighlight %}

As you can see, we used the factory method pattern to make the creation of the app nicer. 

Now that we can create a Splitter object, we want to give it some functionality.

### Work With the Splitted Lists

We want to work with the Lists in the same way that we can work with Streams. But we don't want to recreate every function that a Stream has for our two lists. That's where a nice design pattern comes in handy. I heard about it in this [talk][talk] and it's a very cool way to use lambdas. We basically create two new functions, called `workOnPassedItems` and `workOnNotPassedItems`. They take a `Consumer<Stream<T>>`. Therefore, we can create a lambda and work inside it with a normal looking stream. This method will then be applied onto the List of passed and notPassed items.

{% highlight java %}
public class Splitter<T> {

    //...

    public Splitter workWithPassed(Consumer<Stream<T>> func) {
        func.apply(passed.stream())
        return this;
    }

    public Splitter workWithNotPassed(Consumer<Stream<T>> func) {
        func.apply(notPassed.stream())
        return this;
    }

}
{% endhighlight %}

We used the cascade design pattern here, to make the use of multiple methods nicer. You will see it in the example down below.

And that's basically our Splitter! Now, we can try out some examples on how to use it.

#### Example 1: Showing numbers, but sqauring all odd numbers

In this very first example we want to operate over a list of numbers. For each even number, we just want to print this number out. But for every odd number, we want to square them before we print them out.

So first off, we want to split the list into even and odd numbers. After that, we can work on the lists as already told.

{% highlight java %}
public void workOnNumbers() {
    List<Integer> numbers = Array.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    Splitter.splitBy(numbers, num -> num%2 == 0)
        .workWithPassed(passed -> 
            passed.forEach(even -> System.out.printf("{0} -> {1}", even, even))
        )
        .workWithNotPassed(notPassed -> 
            notPassed.map(odd -> odd * odd)
                .forEach(even -> System.out.printf("{0} -> {1}", Math.sqrt(odd), odd))
        );
}
{% endhighlight %}

#### Example 2: Sending all Winners a Confirmation and all Losers a Cancellation

Now, we have a List of `Candidates`. All of them have a method `hasWon()`, which gives back a boolean. Now, we want to split the List into Winners and Loser. After that, we want to send all Winners a confirmation that they won, and all losers a cancellation that they lost. So let's do this!


{% highlight java %}
public void sendEmails(List<Candidates> candidates) {
    Splitter.splitBy(candidates, Canditates::hasWon)
        .workWithPassed(winners -> 
           winner.forEach(winner -> SendEmail.send(winner.getEmail(), "You won!"));
        )
        .workWithNotPassed(losers -> 
            losers.forEach(loser -> SendEmail.send(loser.getEmail(), "You lost, sorry!"));
        );
}
{% endhighlight %}

## Conclusion
That's it for today!

We have learned how to create our first useful class with the help of Streams. We also optimized the run time of our program with it. Therefore, we have trained our knowledge about design patterns like the factory method and the cascade pattern.

Lastly, we have tried out our splitter with some examples.

Next time, we will talk about RxJava. It's a framework that uses the observer pattern for asynchronus tasks and builds upon functional programming.

Are there any things that your splitter should do too? Please let me know in the comments. I'd love to hear your feedback too!

Thanks for reading and have a nice day,

Niklas

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//flyingbytes.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

[talk]: https://youtu.be/e4MT_OguDKg?t=45m30
