---
layout: post
title:  "An Introduction to Functional Programming in Java 8: Part 4 - Splitter"
date:   2017-02-18 13:00:00 +0100
categories: programming java8 functional part4
---
TODO letzter Absatz: Optimizing with a Builder Pattern
TODO Was, wenn keins den Filter erfüllt? Dann leerer Stream?
TODO Optimieren: Nur eine Function, die mir Stream gibt und ich in einem einzigen Lambda alles damit machen kann?

Hello everybody,

In the [last parts][part3], we've learned about the most basic ways to program functional in Java. We used functions as Objects, Streams and so on for this.

Today, we want to create a useful example with them. You will train the paradicmas of the last parts and learn how the optimize the run time of your program.

## Example: Split a Stream by a specific filter

You might have stumbled over a problem like this before: You have a collection of objects and want to split them by a specific filter. After that, you want to perform some action with all elements who passed the test and another action with the ones that didn't passed the test.

### The Basic (and Slow) Approach

{% highlight java %}
public void splitAndPerform(Collection<T> items, Pedicate<T> splitBy, Function<T> passed, Function<T> notPassed) {
    items.stream()
        .filter(splitBy)
        .forEach(passed)

    items.stream()
        .filter(Predicate.negate(splitBy))
        .forEach(notPassed)
}
{% endhighlight %}

This approch works, but it is pretty slow. The run time for splitting alone is O(2n) TODOMathJax?, because we go through the whole collection 2 times: Ones to get all the items that passed the test and ones to get all the items that didn't passed it.

But what if we would create a splitter on our own? It'd sort all items in the collection, depending on whether or not they pass the test, into one List or the other. This would lower the run time to split the collection to O(n), because you just have to call filter once, not twice.

So let's do this.

## The Better Approach
### 1. Split the Collection

The first step to building our splitter is to, you guessed it, split it.

In our `splitBy()` function, we want to take a `Predeciate<T>` as a parameter and return a new `Splitter` object, which is basically an objects which consists of two Lists. One List consists of all the objects that passed the test, and the other one of all the objects that didn't pass the test.

{% highlight java %}
public class Splitter<T> {

    private List<T> passed;
    private List<T> notPassed;

    private Splitter(List<T> passed, List<T> notPassed) { TODO Wie heißt dieses Pattern, wo private constructor und anderer Constructor
        this.passed = passed;
        this.notPassed = notPassed;
    }

    public splitBy(Predicate<T> test, Collection<T> items){
        List<T> passed = new LinkedList<T>
        List<T> notPassed = new LinkedList<T>

        items.stream()
                .forEach(item -> {
                    if(test.apply(item)){
                        passed.add(item)
                        return;
                    }
                    notPassed.add(item)
                });

        return new Splitter(passed, notPassed);
    }

}
{% endhighlight %}

Now that we can create a Splitter object, we want to give it some functionality.

### Work With the Splitted Lists

We want to work with the Lists in the same way that we can work with Streams. But we don't want to recreate every function that a Stream has for our two lists. That's where the TODODesignPattern comes in handy. I heard about it in this TODOTalk and it's a very cool way to use lambdas. We basically create two new functions, called `workOnPassedItems` and `workOnNotPassedItems`. They take a `Function<Stream<T>, Void>`TODO WieKeinenRückgabewert. Therefore, we can create a lambda and work inside it with a normal looking stream. This method will then be applied onto the List of passed and notPassed items.

{% highlight java %}
public class Splitter<T> {

    //...

    public Splitter workWithPassed(Function<Stream, Void> func) {// TODO wie Function ohne rückgabewert?
        func.apply(passed.stream())
        return this; // TODO Bennene das DesignPattern, (Cascade pattern -> Ist einfach schöner) 
    }

    public Splitter workWithNotPassed(Function<Stream, Void> func) {// TODO wie Function ohne rückgabewert?
        func.apply(notPassed.stream())
        return this; // TODO Bennene das DesignPattern, (Cascade pattern -> Ist einfach schöner) 
    }

}
{% endhighlight %}

And that's basically our Splitter! Now, we can try out some examples on how to use it.

#### Example 1: Showing numbers, but sqauring all odd numbers

In this very first example we want to operate over a list of numbers. For each even number, we just want to print this number out. But for every odd number, we want to square them before we print them out.

So first off, we want to split the list into even and odd numbers. After that, we can work on the lists as already told.

{% highlight java %}
public void workOnNumbers() {
    List<Integer> numbers = Array.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    Splitter.splitBy(numbers, num -> num%2 == 0)
        .workWithPassed(passed -> 
            passed.forEach(even -> System.out.printf("{0} -> {1}", even, even))
        )
        .workWithNotPassed(notPassed -> 
            notPassed.map(odd -> odd * odd)
                .forEach(even -> System.out.printf("{0} -> {1}", Math.sqrt(odd), odd))
        );
}
{% endhighlight %}

#### Example 2: Sending all Winners a Confirmation and all Losers a Cancellation

Now, we have a List of `Candidates`. All of them have a method `hasWon()`, which gives back a boolean. Now, we want to split the List into Winners and Loser. After that, we want to send all Winners a confirmation that they won, and all losers a cancellation that they lost. So let's do this!


{% highlight java %}
public void sendEmails(List<Candidates> candidates) {
    Splitter.splitBy(candidates, Canditates::hasWon)
        .workWithPassed(winners -> 
           winner.forEach(winner -> SendEmail.send(winner.getEmail(), "You won!"));
        )
        .workWithNotPassed(losers -> 
            losers.forEach(loser -> SendEmail.send(loser.getEmail(), "You lost, sorry!"));
        );
}
{% endhighlight %}

## Conclusion
That's it for today!

We have learned a lot about Streams in Java. We learned how to convert a data structure into a Stream, how to work with a Stream and how to convert your Stream back into a data structure.

I have introduced the most common methods and when you should use them.

In the end, we tested our knowledge with a bigger example where we greeted all birthday children.

In the next part of this series, we will have a big example where we are going to use Streams. But I won't tell you the example yet, so be surprised.

Are there any Stream methods that you miss in the post? Please let me know in the comments. I'd love to hear your feedback too!

Thanks for reading and have a nice day,

Niklas

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//flyingbytes.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

[part2]: https://flyingbytes.github.io/programming/java8/functional/part2/2017/02/04/Java8-Part2.html
[javaDocCollection]: https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html
[streamJavaDoc]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html
[javaDocArrays]: https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html
[parallelStream]: https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html
