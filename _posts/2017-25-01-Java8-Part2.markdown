---
layout: post
title:  "An Introduction to Functional Programming in Java 8: Part 1 - Optionals"
date:   2017-01-23 13:00:00 +0100
categories: programming java8 functional part2
---

Hello everybody,

After we've made our first big steps into functional programming in the [last post][part1], we will talk about Optionals in today's part.

## Why do we need Optionals?
Hand on heart, you also think that null is annoying, don't you? For every argument which can be null, you have to check whether it is null or not. 
{% highlight java %}
if(argument == null) {
    throw new NullPointerException();
}
{% endhighlight %}

These lines suck! This is a boilerplate that bloats up your code and can be easily forgotten. So how can we fix that?

## Introducing Optionals
In Java 8, [java.util.Optional<T>][optionalJavaDoc] was invented to handle objects, which might not exists, better. 
It is a container object that can hold an object.
The Generic *T* is the type of the object you want to contain.

{% highlight java %}
Integer i = 5;
Optional<Integer> optinalI = Optional.of(i);
{% endhighlight %}

The Optional //TODOClassOderInterface? doesn't have any public constructor. To create an optional, you have to use `Optional.of(object)` or `Optional.ofNullable(object)`.
You use the first one if the object is never, ever null. The second one is used for nullable objects.

### How do optionals work? 
Options have two states. They either hold an object or they hold null. If they hold an object, optionals are called *present*, if they hold null, they are called *empty*. If they are not empty, you can get the object in the optional by using *Optional.get()*. But be careful, because a *get()* on an empty optional will cause a `NoSuchElementException`. You can check, if a optional is present by calling the method *optional.isPresent()*

#### Example: Playing with Optionals
{% highlight java %}
public void playingWithOptionals() {
    String s = "Hello World!"
    String nullString = null;

    Optional<String> optionalS1 = Optional.of(s); // Will work
    Optional<String> optionalS2 = Optional.ofNullable(s); // Will work too
    Optional<String> optionalNull1 = Optional.of(s); // -> NoSuchElementExeption TODO Wirklich
    Optional<String> optionalNull2 = Optional.ofNullable(s); // Will work

    System.out.print(optionalS1.get()) // prints "Hello World!"
    System.out.print(optionalNull2.get()) // -> "NoSuchElementExeption" TODO Wirklich?
    if(!optionalNull1.isPresent()) {
        System.out.print("Is empty"); // Will be printed
    }
}
{% endhighlight %}

### Common problems with using Optionals
1. Working with Optional //bold and null
{% highlight java %}
public void workWithFirstStringInDB() {
    DBConnection dB = new DBConnection();
    Optional<String> first = dB.getFirstString();

    if(first != null) {
        String value = first.get(); 
        //... 
    }
}
{% endhighlight %}
This is just the wrong use of an optional! If you get an optional (In the example you get one from the DB), you don't have to look whether the object is null or not! If there's no string in the DB, it will return `Optional.empty()`, not `null`! If you get an empty optional in this example, there will be a `NoSuchElementException` when you try to get the value.

2. Working with isPresent() or get()
2.1. Doing something when the value is present
{% highlight java %}
public void workWithFirstStringInDB() {
    DBConnection dB = new DBConnection();
    Optional<String> first = dB.getFirstString();

    if(first.isPresent()) {
        String value = first.get(); 
        //... 
    }
}
{% endhighlight %}
//TODO ifpresent Ist eigentlich apply methode
//TODO Alle Codesnippets in allen Blogbeitr채gen in Text von * * zu ` ` 채ndern.
As I already said, you should always be 100% sure if a optional is present before you use `optional.get()`. So you won't get a `NoSuchElementException` anymore in the updated new code snipped. But you shouldn't check a optional with the `isPresent() + get()` combo! Because if you do it like that, you could have used *null* in the first place. You would replace `first.isPresent()` with `first != null` and you have the same result. But how can we replace this annoying if-block with optionals?

{% highlight java %}
public void workWithFirstStringInDB() {
    DBConnection dB = new DBConnection();
    Optional<String> first = dB.getFirstString();

    first.ifPresent(value -> //...);
}
{% endhighlight %}

The `optional.ifPresent()` method is our new best friend to replace the if. It takes a //TODOWirklich?Function, so a Lambda or method reference, and //f체hrtAus this Lambda only, if the value is present. If you don't remember how to use method references or Lambdas, you should read the [last part][part1] of this series again.

2.2. returning a modified version of the value
{% highlight java %}
public Integer doubleValueOrZero(Optional<Integer> value) {
    if(first.isPresent()) {
       return value.get() * 2;
    }

    return 0;
}
{% endhighlight %}

In this method, we want to double the value of an optional, if it is present, or otherwise, we return 0. The given example works, but it isn't the functional way of seeing this problem.
To make this a lot nicer, we have two function that are comming to help us. The first one is `Optional.map(Function<T, R> mapper)` and `Optional.orElse(T other)`.
`map` takes a function, applies it on the value and returns the result of the function, wrapped in an optional again. If the optional is empty, it will return an empty Optional again.
`orElse` returns the value of the optional it is called on. If the optional is empty, it returns the value you gave the function as a parameter.
With that in mind, we can make this function a one liner

{% highlight java %}
public Integer doubleValueOrZero(Optional<Integer> value) {
    return value.map(*2).orElse(0);
}
{% endhighlight %}

## When should you use null and when Optional.Empty
You can find a lot of books, [talks][optionalTalks] and discussions about the question: Should you use null or Optional in some particular case. And both have there right to be used. In the linked talk, you will find a nice rule which you can apply in most of the cases. Use Optionals when `there is a clear need to represent "no result"` and where null is likely to cause errors.
So you shouldn't use Optionals like this:

{% highlight java %}
public String defaultIfOptional(String string) {
    return Optional.ofNullable(string).orElse("default");
}
{% endhighlight %}

Because a null check is much easier to read.

{% highlight java %}
public String defaultIfOptional(String string) {
    return (string != null) ? string : "default";
}
{% endhighlight %}

Most of the times, you should use optionals just as a return value from a function. It's not a good idea to new ones to create a cool method chain (like in the example above). Most of the times, null is enough.

## Conclusion
That's it for today!
We have played with the Optional class. It's a container class for other classes which is either present or not present(*empty*). We have removed some code smell
We have made our first big steps towards functional programming in Java 8. First off, we have seen a lot of benefits of *fP*. After that, we have used our first function as an argument in another method by using method references and Lambdas(*anonymous functions*).

In part 2, we will introduce *Optionals* and how we can work with them properly.

Thank's for reading and have a nice day, // fix thank's in anderen Blog eintr채gen

Niklas

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//flyingbytes.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

[part1]: https://flyingbytes.github.io/programming/java8/functional/part1/2017/01/23/Java8-Part1.html
[optionalJavaDoc]: https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html
[optionalTalk]: https://www.youtube.com/watch?v=Ej0sss6cq14
